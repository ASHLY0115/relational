<h2>Types and casting rules</h2>

<p>When performing <strong>selection</strong>, implicit casting will be performed to allow the use of operators other than == and !=.</p>

<h4>Rules</h4>

<ul>

<li>If the string matches this regexp: <code>^[\+\-]{0,1}[0-9]+$</code> it will be casted to python's int type</li>
<li>If the string matches this regexp: <code>^[\+\-]{0,1}[0-9]+(\.([0-9])+)?$</code> it will be casted to python's float type</li>
<li>If the string matches this regexp: <code>^([0-9]{1,4})(\\|-|/)([0-9]{1,2})(\\|-|/)([0-9]{1,2})$</code> that represents <em>YYYY-MM-DD date</em>, and the values correctly represent a date, it will be casted to relational's internal rdate type</li>
<li>Otherwise the string will be kept as a string type</li>
</ul>

<p>According to the regexp, a string like '.3' will not be casted to float. I've never liked this format and hence it is forbidden in relational.</p>


<h3>Prevent casting</h3>
<p>Consider the following relation:<p>

<table class="inline">
    <tr class="row0">
        <th class="col0"> id </th><th class="col1"> product </th>
    </tr>
    <tr class="row1">
        <td class="col0"> 113 </td><td class="col1"> scanner </td>
    </tr>
    <tr class="row2">
        <td class="col0"> 113a </td><td class="col1"> new scanner </td>
    </tr>
</table>

<p>
The id field of the 1st tuple will be casted to <code>int</code>, but the same field of the 2nd tuple will not be casted. To avoid anomalies in queries dealing with such fields you must prevent implicit casting.<br />Achieving this is simple, just cast back to string, using <em>str()</em>
</p>

<h4>Example</h4>

<code>σ (str(id).endswith(&#039;3&#039;)) (products)</code>

<h3>Type rdate</h3>
<h4>Fields</h4>

<ul>
<li>day</li>
<li>month</li>
<li>weekday</li>
<li>year</li>
</ul>

<h4>Methods</h4>
Objects of type <code>rdate</code> support the operators <code>+ - == > < >= <= !=</code>.

<h3>Dates</h3>
<p>When a field contains something like 2007-12-24, this will be considered as a date, and will have a particoular behaviour in selection operations.</p>

<h4>Fields</h4>
<table class="inline">
    <tr class="row0">
        <th class="col0"> Field </th><th class="col1"> Description </th>
    </tr>
    <tr class="row1">
        <td class="col0"> intdate </td><td class="col1"> String representation of the date </td>
    </tr>
    <tr class="row2">
        <td class="col0"> day </td><td class="col1 leftalign">  </td>
    </tr>
    <tr class="row3">
        <td class="col0"> month </td><td class="col1"> </td>
    </tr>
    <tr class="row4">
        <td class="col0"> weekday </td><td class="col1"> Day of the week (numeric) </td>
    </tr>
    <tr class="row5">
        <td class="col0"> year </td><td class="col1"> </td>
    </tr>
</table>

<h4>Examples</h4>
<pre><code>Load the file dates.csv and set d as relation's name.
We select every friday:
σ date.weekday==4(d)

We select every date before 2000:
σ date.year<2000 (d)

We rename the field and do the product, we add 2 days to d and see if it is greater than date
σ d+2>date(ρdate➡d(d)*d)
</code></pre>
