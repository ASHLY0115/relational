<h3>Types and casting rules</h3>

<p>When performing <strong>selection</strong>, implicit casting will be performed to allow the use of operators other than == and !=.</p>

<h4>Rules</h4>

<ul>

<li>If the string matches this regexp: <code>^[\+\-]{0,1}[0-9]+$</code> it will be casted to python's int type</li>
<li>If the string matches this regexp: <code>^[\+\-]{0,1}[0-9]+(\.([0-9])+)?$</code> it will be casted to python's float type</li>
<li>If the string matches this regexp: <code>^([0-9]{1,4})(\\|-|/)([0-9]{1,2})(\\|-|/)([0-9]{1,2})$</code> that represents <em>YYYY-MM-DD date</em>, and the values correctly represent a date, it will be casted to relational's internal rdate type</li>
<li>Otherwise the string will be kept as a string type</li>
</ul>

<p>According to the regexp, a string like '.3' will not be casted to float. I've never liked this format and hence it is forbidden in relational.</p>


<h3>Prevent casting</h3>
<p>Consider the following relation:<p>

<table class="inline">
    <tr class="row0">
        <th class="col0"> id </th><th class="col1"> product </th>
    </tr>
    <tr class="row1">
        <td class="col0"> 113 </td><td class="col1"> scanner </td>
    </tr>
    <tr class="row2">
        <td class="col0"> 113a </td><td class="col1"> new scanner </td>
    </tr>
</table>

<p>
The id field of the 1st tuple will be casted to <code>int</code>, but the same field of the 2nd tuple will not be casted. To avoid anomalies in queries dealing with such fields you must prevent implicit casting.<br />Achieving this is simple, just cast back to string, using <em>str()</em>
</p>

<h4>Example</h4>

<code>Ïƒ (str(id).endswith(&#039;3&#039;)) (products)</code>

<h3>Type rdate</h3>
<h4>Fields</h4>

<ul>
<li>day</li>
<li>month</li>
<li>weekday</li>
<li>year</li>
</ul>

<h4>Methods</h4>
Objects of type <code>rdate</code> support the operators <code>+ - == > < >= <= !=</code>.
